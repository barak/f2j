Fortran-to-Java Source Code

Before downloading the f2j source code, realize that f2j is a specific tool
geared to a specific problem - that is, translating LAPACK. However, the
goal is to handle as much Fortran as possible and there's still a lot left
to cover. We have a lot of confidence in the JLAPACK translation, but f2j
will most likely not correctly translate your code at first. It may not
parse or the code generation may not be correct or whatever. We hope that if
you can extend f2j to handle your code, that you'll send us diffs so that we
may then incorporate your fixes into our codebase. Eventually we may put the
code up on a public CVS server, but for now, we'll handle that stuff
locally. The structure of the code is pretty typical for a compiler project.
We have a lexer/parser on the front-end that builds an Abstract Syntax Tree
which is then passed to the back-end for code generation.

Building and Using f2java

We have been doing development and testing of f2j on Sun workstations
running various versions of Solaris. It may compile on other platforms,
though. At least it's worth a shot. Depending on the compiler, you may see
some warnings about unused variables, etc. You can safely ignore them.

First, download and unzip the source code.

Go into the f2j directory and type make.

You may want to add f2j/bin to your PATH because that's the directory in
which f2java and javab (the goto translator) are placed.

To translate a Fortran source file named blah.f, issue the command f2java
blah.f. There are several command-line options that you should be aware of:

   * -p packagename places the specified package name in the generated Java
     source code.
   * -w forces all scalars to be generated as wrapped objects. The default
     behavior is to only wrap those scalars that must be passed by
     reference. Note that using this option will generate less efficient
     Java code.
   * -i causes f2j to generate a high-level interface to each subroutine and
     function. The high-level interface uses a Java-style calling convention
     (2D row-major arrays, etc). The low-level routine is still generated
     because the high-level interface simply performs some conversions and
     then calls the low-level routine.
   * -h displays help information.
   * -s causes f2j to simplify the interfaces by removing the offset
     parameter and using a zero offset. It isn't necessary to specify the -i
     flag in addition to the -s.
   * -d causes f2j to generate comments in a format suitable for javadoc. It
     is a bit of a LAPACK- specfic hack...the longest comment in the program
     unit is placed in the javadoc comment. It works fine for BLAS/LAPACK
     code (or any other code where the longest comment is the one that
     describes the function), but will most likely not work for other code.

After issuing the command f2java blah.f, there should be one or more Java
files and class files in your current directory, one Java file and one
class file per Fortran program unit (function, subroutine, program) in
the source file.  The class file and Java file both implement the same
program unit, but the class file is directly generated by f2j and is
ready to run without futher processing.  We suggest concatenating
all Fortran program units into one file because it allows f2j to perform
more accurate code generation (more about this later). Now you can use the
Java compiler of your choice to compile the resulting code. Make sure that
the org.netlib.util package is in your CLASSPATH. This package comes in the
JLAPACK distribution, so if your CLASSPATH already points to jlapack's
jar files, then you're ok.  At a minimum, your CLASSPATH should point to
f2jutil.jar before continuing.

If successful, compiling the Java code will result in one or more Java class
files being generated. Before you can execute the class files, you need to
perform the GOTO translation by issuing the command javab *.class (assuming
that all your class files are in the current directory). The GOTO
translation tool replaces the class files with the updated versions while
leaving copies of the old class files in files named *.old.

If all the above steps went well, you should be able to execute the class
files in the Java environment of your choice. The next section deals with
what to do if some of the steps didn't work correctly.

Extending f2j

So, at this point you may be wondering how to extend f2j to handle your
code. Typically, the first problem you'll run into is that f2j doesn't parse
your code. That could involve something as simple as changing a production
in the parser or it could involve a bit more work - e.g. creating a new kind
of AST node along with all the appropriate code generation routines. The
first thing you'll want to check is whether the parser supports the syntax
your code uses (the parsing code is machine generated from a Yacc parser in
f2jparse.y). For example, if your code contains an IMPLICIT statement
(besides IMPLICIT NONE), your code will not compile because f2j doesn't
support implicit typing. Suppose you wanted to implement implicit typing in
f2j. Your first step would be to modify the "Implicit" production in the
parser to allow the statement. Then you'd probably have to modify the "type
assignment" code in typecheck.c, but you shouldn't need to change the code
generator (codegen.c). The second thing you'll want to check if your code
doesn't parse is whether the lexer is acting up. If you're getting parse
errors on a line of code that should compile based on your examination of
the parser, then the lexer might not be sending the correct tokens to the
parser. The lexical analysis code is in f2jlex.c, which is handwritten C
code based on Sale's algorithm. There's not really an easy way of describing
the structure of the lexer code, but if you enable debugging output (set
lexdebug = TRUE) it should help you figure out where the problem is.

If f2j can parse your code, but the resulting Java code does not compile or
does not work, then this may indicate a problem in the f2j back-end. First,
try concatenating all your fortran files into one big file (ok, we admit
this is cheesy, but we haven't implemented multiple file handling yet). This
should help with the type analysis phase and may eliminate problems in the
resulting Java code. After that, if the generated code is still incorrect,
begin looking into the f2j code. After f2j parses your code, it passes
through a couple of stages before actually generating code. First, the AST
goes through 'type analysis' (typecheck.c), which simply means that the tree
is fully traversed and each node is assigned type information as
appropriate. This is not semantic analysis, just annotation. Next, the AST
goes through 'scalar optimization' (optimize.c), which is an optimization
stage designed to determine which scalar variables need to be wrapped in
objects and which can remain primitives. After that, f2j generates the java
code (codegen.c) based on the modified AST. So, if you notice a type
mismatch problem in the generated code, typecheck.c would be a good place to
begin debugging. Similarly, if you notice that object wrappers are
inappropriately used, check into optimize.c (hint: by passing the -w flag to
f2java, the scalar optimization code will be skipped). Most other problems
will be with the code generator itself.

If you're ambitious, you might try grafting a full Fortran 77 front-end onto
f2j and start building up the back-end to accommodate all the new AST nodes.
Or you might just try fully implementing Fortran's I/O routines for f2j.

Tips

   * f2java -h provides a help screen.
   * For best results, concatenate all Fortran files into one source file.
   * Remember to run the goto translation program on the resulting bytecode.
   * Jasmin code generation is broken.
   * VCG graph generation is broken, too.
   * Last line of input can't begin with a TAB.
   * DIMENSION not implemented.
   * more to come...

LICENSE

The license covering the f2j source code is basically GPL with the addition
of the BSD advertising clause.

The GOTO translation code is based on the bytecode parser found in javab, a
bytecode parallelizing tool under development at the University of Indiana.
This code is covered under its original license, found in the translator
source directory.
