<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1 (Feb 5, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>Lexing FORTRAN</TITLE>
<META NAME="description" CONTENT="Lexing FORTRAN">
<META NAME="keywords" CONTENT="f2jreport">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="f2jreport.css">
</HEAD>
<BODY LANG="EN">
 <A NAME="tex2html324" HREF="node24.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="http://www.cs.utk.edu/~icl/WebSite/icons/next_motif.gif"></A> <A NAME="tex2html322" HREF="node22.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="http://www.cs.utk.edu/~icl/WebSite/icons/up_motif.gif"></A> <A NAME="tex2html316" HREF="node22.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="http://www.cs.utk.edu/~icl/WebSite/icons/previous_motif.gif"></A>   <BR>
<B> Next:</B> <A NAME="tex2html325" HREF="node24.html">Parsing FORTRAN</A>
<B>Up:</B> <A NAME="tex2html323" HREF="node22.html">Implemention of the f2j </A>
<B> Previous:</B> <A NAME="tex2html317" HREF="node22.html">Implemention of the f2j </A>
<BR> <P>
<H3><A NAME="SECTION00022100000000000000">Lexing F<font size=-1><small>ORTRAN</small></font></A></H3>
<P>
<BLOCKQUOTE> <EM>
It should be noted that tokenizing F<font size=-1><small>ORTRAN</small></font> is such
an irregular task that it is frequently easier to 
write an ad hoc lexical analyzer for F<font size=-1><small>ORTRAN</small></font> in a
conventional programming language than it is to use an
automatic lexical analyzer 
generator. --Alfred Aho, 1988&nbsp;[<A HREF="node35.html#ahoav88">12</A>]
</EM>
</BLOCKQUOTE>
<P>
Lexing F<font size=-1><small>ORTRAN</small></font>  is somewhat difficult because 
keywords (e.g., IF, DO, etc.) are not reserved. 
Thus keywords can also be used as variable names.
To properly lex F<font size=-1><small>ORTRAN</small></font>, each statement must be 
examined for context, which requires lookahead. 
Sale published an algorithm 
for lexing F<font size=-1><small>ORTRAN</small></font> in CACM in the 1960's.  Fortunately,
once F<font size=-1><small>ORTRAN</small></font> is lexed, it is fairly easy to
parse.
<P>
In general, the 
f2j lexer aspires to be a F<font size=-1><small>ORTRAN</small></font> specific variant 
of the <I>lex</I> lexical analysis tool.
The compiler uses global variables so that the 
parser's <TT>yyparse</TT> procedure can communicate
with the  lexer's <TT>yylex</TT> procedure.  
Global variables, such as <TT>yytext</TT> and <TT>yylval</TT>,
are typed in the header file f2j.h, and 
declared <TT>extern</TT> in the functions that use them.
Line numbers are counted and provided in error messages
to help identify the erroneous statement.
<P>
Lexing in f2j is a two phase process consisting of
a scan phase and a lexical analysis phase.
The scan phase removes whitespace and comments,
catenates continued lines together, marks the end of
file and implements Sale's algorithm (Appendix&nbsp;<A HREF="node36.html#appsales">A</A>)
to determine context.
The lexical analysis phase implements a custom-written
<TT>yylex</TT> procedure to provide tokens to the parser,
<TT>yyparse</TT>, which is generated by the <I>Bison</I>
parser generator.  
<TT>yylex</TT> implements a scan phase at the beginning 
of every F<font size=-1><small>ORTRAN</small></font> statement by calling 
several procedures to manipulate the statement 
input string from the 
source file into a valid F<font size=-1><small>ORTRAN</small></font> statement.
The statement is scanned, lexed, and the next token,
along with its lexical value, is made available 
to the parser.
<P>
At the beginning of every F<font size=-1><small>ORTRAN</small></font> input statement,
<TT>prelex()</TT> is called to read a line from the F<font size=-1><small>ORTRAN</small></font> input
file, disposing of comment lines until a valid line
is found.  Once a valid line is found, the line buffer is
passed to <TT>check_continued_lines()</TT>, which does a 
look-ahead to the sixth column of the next line.  If there
is a ``continuation'' character in the sixth position, the next
line is read and catenated to the previous line, 
incrementing the (global) file pointer.
If there is no continuation character, the file pointer is reset for the
next call to <TT>prelex()</TT>.
<P>
Once <TT>check_continued_lines()</TT> returns a complete 
statement, <TT>collapse_white_space()</TT> removes all
spaces, tabs and newlines from the statement.
Extra newlines embedded between continued lines
would result in a parse error since newlines are 
used as F<font size=-1><small>ORTRAN</small></font>'s statement delimiter. 
This is done in a loop, incrementing a character pointer 
that is dereferenced to compare characters.
After all whitespace is removed, one newline is catenated
to the very end
of the statement which can be passed as a token to the 
parser.  <TT>collapse_white_space()</TT> also changes
characters into upper case, with the exception 
of F<font size=-1><small>ORTRAN</small></font> character arrays, enclosed between 
tick (') marks, that are passed back as literal text
in the statement buffer as well as in the text buffer.
Also, Sale's algorithm (Appendix&nbsp;<A HREF="node36.html#appsales">A</A>)
 is implemented to determine context.
Once the white space is removed, <TT>prelex()</TT> 
increments the line number
and control passes back to <TT>yylex()</TT>.
<P>
In the lexical analysis phase, statements are scanned 
for tokens according to the context determined from the 
prepass.  The <TT>yylex()</TT> procedure calls one of three
scanning procedures, <TT>keyscan()</TT>, <TT>name_scan()</TT>,
or <TT>number_scan()</TT> to extract tokens from statements.
<TT>keyscan()</TT> takes tables of keywords or symbols defined
as part of the F<font size=-1><small>ORTRAN</small></font> language language, along with the 
statement buffers returned from the prepass.  <TT>name_scan</TT>
and <TT>number_scan()</TT> only take the statement buffer 
arguments.  All scanning routines modify the statement buffers 
and return tokens along with any lexical values present.
<P>
The <TT>keyscan()</TT> routine takes one of three tables
defined in an initialization header file.
The tables contain either  keywords, types or
symbols.  The appropriate table is chosen by context 
determined from the prepass.
Table scanning is accomplished by determining the 
length of the word or symbol string, then string comparing
to determine a match.  A successful match advances a 
character pointer to the end of the new token, which is returned
along with any lexical value.  The remaining string is 
copied into the statement buffer.  The lexical values are 
determined from the matching source code text buffer.
The tables are split into three types:  one for F<font size=-1><small>ORTRAN</small></font> 
key words (IF, DO, etc.), one for F<font size=-1><small>ORTRAN</small></font> types (REAL, INTEGER, etc.),
and one for symbols (+, =, etc.).
<P>
The <TT>name_scan()</TT> function is called if there is no context for a 
key word, and if the character pointed to by the statement 
buffer is alphabetic.  <TT>name_scan()</TT> loops over the 
characters in the statement buffer, advancing a character 
pointer until a non-alphanumeric character is seen.  Then 
the statement and text buffers are updated and the NAME
token is passed back to <TT>yylex()</TT>.  The lexical value is 
copied into the global union variable <TT>yylval</TT> for use by 
<TT>yyparse()</TT> when NAME is reduced.
<P>
The <TT>number_scan()</TT> procedure addresses some other 
lexical questions associated with F<font size=-1><small>ORTRAN</small></font>, such as the 
look-ahead needed to determine whether the characters 
``123'' reduce to an integer in the relational operation
<TT>123.EQ.I</TT>.   This is accomplished by advancing a 
character pointer over the statement buffer while the 
current character is a digit or any of the characters
in the set {D, d, E, e, .}. Encountering a ``.'' 
during the loop causes the required look-ahead to 
determine whether the number is an integer or
a floating point number.  Encountering  any of the 
letter D, d, E, or e invokes more look-ahead to 
determine the sign of the associated exponent.
The procedure returns tokens and values similarly to 
<TT>name_scan()</TT>.
<P>
<HR><A NAME="tex2html324" HREF="node24.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="http://www.cs.utk.edu/~icl/WebSite/icons/next_motif.gif"></A> <A NAME="tex2html322" HREF="node22.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="http://www.cs.utk.edu/~icl/WebSite/icons/up_motif.gif"></A> <A NAME="tex2html316" HREF="node22.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="http://www.cs.utk.edu/~icl/WebSite/icons/previous_motif.gif"></A>   <BR>
<B> Next:</B> <A NAME="tex2html325" HREF="node24.html">Parsing FORTRAN</A>
<B>Up:</B> <A NAME="tex2html323" HREF="node22.html">Implemention of the f2j </A>
<B> Previous:</B> <A NAME="tex2html317" HREF="node22.html">Implemention of the f2j </A>
<P><ADDRESS>
<I>Keith Seymour <BR>
Wed Jun 10 19:38:14 EDT 1998</I>
</ADDRESS>
</BODY>
</HTML>
