<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Fri Jan 22 13:19:44 EST 1999 -->
<title>
  Class org.netlib.lapack.DSTEBZ
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.DSPTRS.html#_top_">Previous</a>  <a href="org.netlib.lapack.DSTEDC.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class org.netlib.lapack.DSTEBZ
</h1>
<pre>
java.lang.Object
   |
   +----org.netlib.lapack.DSTEBZ
</pre>
<hr>
<dl>
  <dt> public class <b>DSTEBZ</b>
  <dt> extends Object
</dl>
<pre>
<b>DSTEBZ</b> is a simplified interface to the JLAPACK routine <b>dstebz</b>.
This interface converts Java-style 2D row-major arrays into
the 1D column-major linearized arrays expected by the lower
level JLAPACK routines.  Using this interface also allows you
to omit offset and leading dimension arguments.  However, because
of these conversions, these routines will be slower than the low
level ones.  Following is the description from the original Fortran
source.  Contact <a href="mailto:seymour@cs.utk.edu">seymour@cs.utk.edu</a> with any questions.
<p>
 *     ..
 *
 *  Purpose
 *  =======
 *
 *  DSTEBZ computes the eigenvalues of a symmetric tridiagonal
 *  matrix T.  The user may ask for all eigenvalues, all eigenvalues
 *  in the half-open interval (VL, VU], or the IL-th through IU-th
 *  eigenvalues.
 *
 *  To avoid overflow, the matrix must be scaled so that its
 *  largest element is no greater than overflow**(1/2) *
 *  underflow**(1/4) in absolute value, and for greatest
 *  accuracy, it should not be much smaller than that.
 *
 *  See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 *  Matrix", Report CS41, Computer Science Dept., Stanford
 *  University, July 21, 1966.
 *
 *  Arguments
 *  =========
 *
 *  RANGE   (input) CHARACTER
 *          = 'A': ("All")   all eigenvalues will be found.
 *          = 'V': ("Value") all eigenvalues in the half-open interval
 *                           (VL, VU] will be found.
 *          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
 *                           entire matrix) will be found.
 *
 *  ORDER   (input) CHARACTER
 *          = 'B': ("By Block") the eigenvalues will be grouped by
 *                              split-off block (see IBLOCK, ISPLIT) and
 *                              ordered from smallest to largest within
 *                              the block.
 *          = 'E': ("Entire matrix")
 *                              the eigenvalues for the entire matrix
 *                              will be ordered from smallest to
 *                              largest.
 *
 *  N       (input) INTEGER
 *          The order of the tridiagonal matrix T.  N >= 0.
 *
 *  VL      (input) DOUBLE PRECISION
 *  VU      (input) DOUBLE PRECISION
 *          If RANGE='V', the lower and upper bounds of the interval to
 *          be searched for eigenvalues.  Eigenvalues less than or equal
 *          to VL, or greater than VU, will not be returned.  VL < VU.
 *          Not referenced if RANGE = 'A' or 'I'.
 *
 *  IL      (input) INTEGER
 *  IU      (input) INTEGER
 *          If RANGE='I', the indices (in ascending order) of the
 *          smallest and largest eigenvalues to be returned.
 *          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
 *          Not referenced if RANGE = 'A' or 'V'.
 *
 *  ABSTOL  (input) DOUBLE PRECISION
 *          The absolute tolerance for the eigenvalues.  An eigenvalue
 *          (or cluster) is considered to be located if it has been
 *          determined to lie in an interval whose width is ABSTOL or
 *          less.  If ABSTOL is less than or equal to zero, then ULP*|T|
 *          will be used, where |T| means the 1-norm of T.
 *
 *          Eigenvalues will be computed most accurately when ABSTOL is
 *          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
 *
 *  D       (input) DOUBLE PRECISION array, dimension (N)
 *          The n diagonal elements of the tridiagonal matrix T.
 *
 *  E       (input) DOUBLE PRECISION array, dimension (N-1)
 *          The (n-1) off-diagonal elements of the tridiagonal matrix T.
 *
 *  M       (output) INTEGER
 *          The actual number of eigenvalues found. 0 <= M <= N.
 *          (See also the description of INFO=2,3.)
 *
 *  NSPLIT  (output) INTEGER
 *          The number of diagonal blocks in the matrix T.
 *          1 <= NSPLIT <= N.
 *
 *  W       (output) DOUBLE PRECISION array, dimension (N)
 *          On exit, the first M elements of W will contain the
 *          eigenvalues.  (DSTEBZ may use the remaining N-M elements as
 *          workspace.)
 *
 *  IBLOCK  (output) INTEGER array, dimension (N)
 *          At each row/column j where E(j) is zero or small, the
 *          matrix T is considered to split into a block diagonal
 *          matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which
 *          block (from 1 to the number of blocks) the eigenvalue W(i)
 *          belongs.  (DSTEBZ may use the remaining N-M elements as
 *          workspace.)
 *
 *  ISPLIT  (output) INTEGER array, dimension (N)
 *          The splitting points, at which T breaks up into submatrices.
 *          The first submatrix consists of rows/columns 1 to ISPLIT(1),
 *          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
 *          etc., and the NSPLIT-th consists of rows/columns
 *          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.
 *          (Only the first NSPLIT elements will actually be used, but
 *          since the user cannot know a priori what value NSPLIT will
 *          have, N words must be reserved for ISPLIT.)
 *
 *  WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)
 *
 *  IWORK   (workspace) INTEGER array, dimension (3*N)
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  if INFO = -i, the i-th argument had an illegal value
 *          > 0:  some or all of the eigenvalues failed to converge or
 *                were not computed:
 *                =1 or 3: Bisection failed to converge for some
 *                        eigenvalues; these eigenvalues are flagged by a
 *                        negative block number.  The effect is that the
 *                        eigenvalues may not be as accurate as the
 *                        absolute and relative tolerances.  This is
 *                        generally caused by unexpectedly inaccurate
 *                        arithmetic.
 *                =2 or 3: RANGE='I' only: Not all of the eigenvalues
 *                        IL:IU were found.
 *                        Effect: M < IU+1-IL
 *                        Cause:  non-monotonic arithmetic, causing the
 *                                Sturm sequence to be non-monotonic.
 *                        Cure:   recalculate, using RANGE='A', and pick
 *                                out eigenvalues IL:IU.  In some cases,
 *                                increasing the PARAMETER "FUDGE" may
 *                                make things work.
 *                = 4:    RANGE='I', and the Gershgorin interval
 *                        initially used was too small.  No eigenvalues
 *                        were computed.
 *                        Probable cause: your machine has sloppy
 *                                        floating-point arithmetic.
 *                        Cure: Increase the PARAMETER "FUDGE",
 *                              recompile, and try again.
 *
 *  Internal Parameters
 *  ===================
 *
 *  RELFAC  DOUBLE PRECISION, default = 2.0e0
 *          The relative tolerance.  An interval (a,b] lies within
 *          "relative tolerance" if  b-a < RELFAC*ulp*max(|a|,|b|),
 *          where "ulp" is the machine precision (distance from 1 to
 *          the next larger floating point number.)
 *
 *  FUDGE   DOUBLE PRECISION, default = 2
 *          A "fudge factor" to widen the Gershgorin intervals.  Ideally,
 *          a value of 1 should work, but on machines with sloppy
 *          arithmetic, this needs to be larger.  The default for
 *          publicly released versions should be large enough to handle
 *          the worst machine around.  Note that this has no effect
 *          on accuracy of the solution.
 *
 *  =====================================================================
 *
 *     .. Parameters ..
</pre>
<p>
<hr>
<a name="index"></a>
<h2>
  <img src="images/constructor-index.gif" width=275 height=38 alt="Constructor Index">
</h2>
<dl>
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DSTEBZ()"><b>DSTEBZ</b></a>()
  <dd> 
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DSTEBZ(java.lang.String, java.lang.String, int, double, double, int, int, double, double[], double[], org.netlib.util.intW, org.netlib.util.intW, double[], int[], int[], double[], int[], org.netlib.util.intW)"><b>DSTEBZ</b></a>(String, String, int, double, double, int, int, double, double[], double[], intW, intW, double[], int[], int[], double[], int[], intW)
  <dd> 
</dl>
<a name="constructors"></a>
<h2>
  <img src="images/constructors.gif" width=231 height=38 alt="Constructors">
</h2>
<a name="DSTEBZ"></a>
<a name="DSTEBZ()"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>DSTEBZ</b>
<pre>
 public DSTEBZ()
</pre>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="DSTEBZ(java.lang.String, java.lang.String, int, double, double, int, int, double, double[], double[], org.netlib.util.intW, org.netlib.util.intW, double[], int[], int[], double[], int[], org.netlib.util.intW)"><img src="images/green-ball.gif" width=12 height=12 alt=" o "></a>
<a name="DSTEBZ"><b>DSTEBZ</b></a>
<pre>
 public static void DSTEBZ(String range,
                           String order,
                           int n,
                           double vl,
                           double vu,
                           int il,
                           int iu,
                           double abstol,
                           double d[],
                           double e[],
                           <a href="org.netlib.util.intW.html#_top_">intW</a> m,
                           <a href="org.netlib.util.intW.html#_top_">intW</a> nsplit,
                           double w[],
                           int iblock[],
                           int isplit[],
                           double work[],
                           int iwork[],
                           <a href="org.netlib.util.intW.html#_top_">intW</a> info)
</pre>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.DSPTRS.html#_top_">Previous</a>  <a href="org.netlib.lapack.DSTEDC.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
