<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Fri Jan 22 13:19:44 EST 1999 -->
<title>
  Class org.netlib.lapack.DGGHRD
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.DGGGLM.html#_top_">Previous</a>  <a href="org.netlib.lapack.DGGLSE.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class org.netlib.lapack.DGGHRD
</h1>
<pre>
java.lang.Object
   |
   +----org.netlib.lapack.DGGHRD
</pre>
<hr>
<dl>
  <dt> public class <b>DGGHRD</b>
  <dt> extends Object
</dl>
<pre>
<b>DGGHRD</b> is a simplified interface to the JLAPACK routine <b>dgghrd</b>.
This interface converts Java-style 2D row-major arrays into
the 1D column-major linearized arrays expected by the lower
level JLAPACK routines.  Using this interface also allows you
to omit offset and leading dimension arguments.  However, because
of these conversions, these routines will be slower than the low
level ones.  Following is the description from the original Fortran
source.  Contact <a href="mailto:seymour@cs.utk.edu">seymour@cs.utk.edu</a> with any questions.
<p>
 *     ..
 *
 *  Purpose
 *  =======
 *
 *  DGGHRD reduces a pair of real matrices (A,B) to generalized upper
 *  Hessenberg form using orthogonal transformations, where A is a
 *  general matrix and B is upper triangular:  Q' * A * Z = H and
 *  Q' * B * Z = T, where H is upper Hessenberg, T is upper triangular,
 *  and Q and Z are orthogonal, and ' means transpose.
 *
 *  The orthogonal matrices Q and Z are determined as products of Givens
 *  rotations.  They may either be formed explicitly, or they may be
 *  postmultiplied into input matrices Q1 and Z1, so that
 *
 *       Q1 * A * Z1' = (Q1*Q) * H * (Z1*Z)'
 *       Q1 * B * Z1' = (Q1*Q) * T * (Z1*Z)'
 *
 *  Arguments
 *  =========
 *
 *  COMPQ   (input) CHARACTER*1
 *          = 'N': do not compute Q;
 *          = 'I': Q is initialized to the unit matrix, and the
 *                 orthogonal matrix Q is returned;
 *          = 'V': Q must contain an orthogonal matrix Q1 on entry,
 *                 and the product Q1*Q is returned.
 *
 *  COMPZ   (input) CHARACTER*1
 *          = 'N': do not compute Z;
 *          = 'I': Z is initialized to the unit matrix, and the
 *                 orthogonal matrix Z is returned;
 *          = 'V': Z must contain an orthogonal matrix Z1 on entry,
 *                 and the product Z1*Z is returned.
 *
 *  N       (input) INTEGER
 *          The order of the matrices A and B.  N >= 0.
 *
 *  ILO     (input) INTEGER
 *  IHI     (input) INTEGER
 *          It is assumed that A is already upper triangular in rows and
 *          columns 1:ILO-1 and IHI+1:N.  ILO and IHI are normally set
 *          by a previous call to DGGBAL; otherwise they should be set
 *          to 1 and N respectively.
 *          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
 *
 *  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
 *          On entry, the N-by-N general matrix to be reduced.
 *          On exit, the upper triangle and the first subdiagonal of A
 *          are overwritten with the upper Hessenberg matrix H, and the
 *          rest is set to zero.
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,N).
 *
 *  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
 *          On entry, the N-by-N upper triangular matrix B.
 *          On exit, the upper triangular matrix T = Q' B Z.  The
 *          elements below the diagonal are set to zero.
 *
 *  LDB     (input) INTEGER
 *          The leading dimension of the array B.  LDB >= max(1,N).
 *
 *  Q       (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
 *          If COMPQ='N':  Q is not referenced.
 *          If COMPQ='I':  on entry, Q need not be set, and on exit it
 *                         contains the orthogonal matrix Q, where Q'
 *                         is the product of the Givens transformations
 *                         which are applied to A and B on the left.
 *          If COMPQ='V':  on entry, Q must contain an orthogonal matrix
 *                         Q1, and on exit this is overwritten by Q1*Q.
 *
 *  LDQ     (input) INTEGER
 *          The leading dimension of the array Q.
 *          LDQ >= N if COMPQ='V' or 'I'; LDQ >= 1 otherwise.
 *
 *  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
 *          If COMPZ='N':  Z is not referenced.
 *          If COMPZ='I':  on entry, Z need not be set, and on exit it
 *                         contains the orthogonal matrix Z, which is
 *                         the product of the Givens transformations
 *                         which are applied to A and B on the right.
 *          If COMPZ='V':  on entry, Z must contain an orthogonal matrix
 *                         Z1, and on exit this is overwritten by Z1*Z.
 *
 *  LDZ     (input) INTEGER
 *          The leading dimension of the array Z.
 *          LDZ >= N if COMPZ='V' or 'I'; LDZ >= 1 otherwise.
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit.
 *          < 0:  if INFO = -i, the i-th argument had an illegal value.
 *
 *  Further Details
 *  ===============
 *
 *  This routine reduces A to Hessenberg and B to triangular form by
 *  an unblocked reduction, as described in _Matrix_Computations_,
 *  by Golub and Van Loan (Johns Hopkins Press.)
 *
 *  =====================================================================
 *
 *     .. Parameters ..
</pre>
<p>
<hr>
<a name="index"></a>
<h2>
  <img src="images/constructor-index.gif" width=275 height=38 alt="Constructor Index">
</h2>
<dl>
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DGGHRD()"><b>DGGHRD</b></a>()
  <dd> 
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DGGHRD(java.lang.String, java.lang.String, int, int, int, double[][], double[][], double[][], double[][], org.netlib.util.intW)"><b>DGGHRD</b></a>(String, String, int, int, int, double[][], double[][], double[][], double[][], intW)
  <dd> 
</dl>
<a name="constructors"></a>
<h2>
  <img src="images/constructors.gif" width=231 height=38 alt="Constructors">
</h2>
<a name="DGGHRD"></a>
<a name="DGGHRD()"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>DGGHRD</b>
<pre>
 public DGGHRD()
</pre>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="DGGHRD(java.lang.String, java.lang.String, int, int, int, double[][], double[][], double[][], double[][], org.netlib.util.intW)"><img src="images/green-ball.gif" width=12 height=12 alt=" o "></a>
<a name="DGGHRD"><b>DGGHRD</b></a>
<pre>
 public static void DGGHRD(String compq,
                           String compz,
                           int n,
                           int ilo,
                           int ihi,
                           double a[][],
                           double b[][],
                           double q[][],
                           double z[][],
                           <a href="org.netlib.util.intW.html#_top_">intW</a> info)
</pre>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.DGGGLM.html#_top_">Previous</a>  <a href="org.netlib.lapack.DGGLSE.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
