<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Fri Jan 22 13:19:44 EST 1999 -->
<title>
  Class org.netlib.lapack.DGESVD
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.DGESV.html#_top_">Previous</a>  <a href="org.netlib.lapack.DGESVX.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class org.netlib.lapack.DGESVD
</h1>
<pre>
java.lang.Object
   |
   +----org.netlib.lapack.DGESVD
</pre>
<hr>
<dl>
  <dt> public class <b>DGESVD</b>
  <dt> extends Object
</dl>
<pre>
<b>DGESVD</b> is a simplified interface to the JLAPACK routine <b>dgesvd</b>.
This interface converts Java-style 2D row-major arrays into
the 1D column-major linearized arrays expected by the lower
level JLAPACK routines.  Using this interface also allows you
to omit offset and leading dimension arguments.  However, because
of these conversions, these routines will be slower than the low
level ones.  Following is the description from the original Fortran
source.  Contact <a href="mailto:seymour@cs.utk.edu">seymour@cs.utk.edu</a> with any questions.
<p>
 *     ..
 *
 *  Purpose
 *  =======
 *
 *  DGESVD computes the singular value decomposition (SVD) of a real
 *  M-by-N matrix A, optionally computing the left and/or right singular
 *  vectors. The SVD is written
 *
 *       A = U * SIGMA * transpose(V)
 *
 *  where SIGMA is an M-by-N matrix which is zero except for its
 *  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
 *  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
 *  are the singular values of A; they are real and non-negative, and
 *  are returned in descending order.  The first min(m,n) columns of
 *  U and V are the left and right singular vectors of A.
 *
 *  Note that the routine returns V**T, not V.
 *
 *  Arguments
 *  =========
 *
 *  JOBU    (input) CHARACTER*1
 *          Specifies options for computing all or part of the matrix U:
 *          = 'A':  all M columns of U are returned in array U:
 *          = 'S':  the first min(m,n) columns of U (the left singular
 *                  vectors) are returned in the array U;
 *          = 'O':  the first min(m,n) columns of U (the left singular
 *                  vectors) are overwritten on the array A;
 *          = 'N':  no columns of U (no left singular vectors) are
 *                  computed.
 *
 *  JOBVT   (input) CHARACTER*1
 *          Specifies options for computing all or part of the matrix
 *          V**T:
 *          = 'A':  all N rows of V**T are returned in the array VT;
 *          = 'S':  the first min(m,n) rows of V**T (the right singular
 *                  vectors) are returned in the array VT;
 *          = 'O':  the first min(m,n) rows of V**T (the right singular
 *                  vectors) are overwritten on the array A;
 *          = 'N':  no rows of V**T (no right singular vectors) are
 *                  computed.
 *
 *          JOBVT and JOBU cannot both be 'O'.
 *
 *  M       (input) INTEGER
 *          The number of rows of the input matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the input matrix A.  N >= 0.
 *
 *  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
 *          On entry, the M-by-N matrix A.
 *          On exit,
 *          if JOBU = 'O',  A is overwritten with the first min(m,n)
 *                          columns of U (the left singular vectors,
 *                          stored columnwise);
 *          if JOBVT = 'O', A is overwritten with the first min(m,n)
 *                          rows of V**T (the right singular vectors,
 *                          stored rowwise);
 *          if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
 *                          are destroyed.
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
 *          The singular values of A, sorted so that S(i) >= S(i+1).
 *
 *  U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
 *          (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
 *          If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
 *          if JOBU = 'S', U contains the first min(m,n) columns of U
 *          (the left singular vectors, stored columnwise);
 *          if JOBU = 'N' or 'O', U is not referenced.
 *
 *  LDU     (input) INTEGER
 *          The leading dimension of the array U.  LDU >= 1; if
 *          JOBU = 'S' or 'A', LDU >= M.
 *
 *  VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
 *          If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
 *          V**T;
 *          if JOBVT = 'S', VT contains the first min(m,n) rows of
 *          V**T (the right singular vectors, stored rowwise);
 *          if JOBVT = 'N' or 'O', VT is not referenced.
 *
 *  LDVT    (input) INTEGER
 *          The leading dimension of the array VT.  LDVT >= 1; if
 *          JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
 *
 *  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
 *          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
 *          if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged
 *          superdiagonal elements of an upper bidiagonal matrix B
 *          whose diagonal is in S (not necessarily sorted). B
 *          satisfies A = U * B * VT, so it has the same singular values
 *          as A, and singular vectors related by U and VT.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK. LWORK >= 1.
 *          LWORK >= MAX(3*MIN(M,N)+MAX(M,N),5*MIN(M,N)-4).
 *          For good performance, LWORK should generally be larger.
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit.
 *          < 0:  if INFO = -i, the i-th argument had an illegal value.
 *          > 0:  if DBDSQR did not converge, INFO specifies how many
 *                superdiagonals of an intermediate bidiagonal form B
 *                did not converge to zero. See the description of WORK
 *                above for details.
 *
 *  =====================================================================
 *
 *     .. Parameters ..
</pre>
<p>
<hr>
<a name="index"></a>
<h2>
  <img src="images/constructor-index.gif" width=275 height=38 alt="Constructor Index">
</h2>
<dl>
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DGESVD()"><b>DGESVD</b></a>()
  <dd> 
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DGESVD(java.lang.String, java.lang.String, int, int, double[][], double[], double[][], double[][], double[], int, org.netlib.util.intW)"><b>DGESVD</b></a>(String, String, int, int, double[][], double[], double[][], double[][], double[], int, intW)
  <dd> 
</dl>
<a name="constructors"></a>
<h2>
  <img src="images/constructors.gif" width=231 height=38 alt="Constructors">
</h2>
<a name="DGESVD"></a>
<a name="DGESVD()"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>DGESVD</b>
<pre>
 public DGESVD()
</pre>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="DGESVD(java.lang.String, java.lang.String, int, int, double[][], double[], double[][], double[][], double[], int, org.netlib.util.intW)"><img src="images/green-ball.gif" width=12 height=12 alt=" o "></a>
<a name="DGESVD"><b>DGESVD</b></a>
<pre>
 public static void DGESVD(String jobu,
                           String jobvt,
                           int m,
                           int n,
                           double a[][],
                           double s[],
                           double u[][],
                           double vt[][],
                           double work[],
                           int lwork,
                           <a href="org.netlib.util.intW.html#_top_">intW</a> info)
</pre>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.DGESV.html#_top_">Previous</a>  <a href="org.netlib.lapack.DGESVX.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
