<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Fri Jan 22 13:19:44 EST 1999 -->
<title>
  Class org.netlib.lapack.DTREVC
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.DTRCON.html#_top_">Previous</a>  <a href="org.netlib.lapack.DTREXC.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class org.netlib.lapack.DTREVC
</h1>
<pre>
java.lang.Object
   |
   +----org.netlib.lapack.DTREVC
</pre>
<hr>
<dl>
  <dt> public class <b>DTREVC</b>
  <dt> extends Object
</dl>
<pre>
<b>DTREVC</b> is a simplified interface to the JLAPACK routine <b>dtrevc</b>.
This interface converts Java-style 2D row-major arrays into
the 1D column-major linearized arrays expected by the lower
level JLAPACK routines.  Using this interface also allows you
to omit offset and leading dimension arguments.  However, because
of these conversions, these routines will be slower than the low
level ones.  Following is the description from the original Fortran
source.  Contact <a href="mailto:seymour@cs.utk.edu">seymour@cs.utk.edu</a> with any questions.
<p>
 *     ..
 *
 *  Purpose
 *  =======
 *
 *  DTREVC computes some or all of the right and/or left eigenvectors of
 *  a real upper quasi-triangular matrix T.
 *
 *  The right eigenvector x and the left eigenvector y of T corresponding
 *  to an eigenvalue w are defined by:
 *
 *               T*x = w*x,     y'*T = w*y'
 *
 *  where y' denotes the conjugate transpose of the vector y.
 *
 *  If all eigenvectors are requested, the routine may either return the
 *  matrices X and/or Y of right or left eigenvectors of T, or the
 *  products Q*X and/or Q*Y, where Q is an input orthogonal
 *  matrix. If T was obtained from the real-Schur factorization of an
 *  original matrix A = Q*T*Q', then Q*X and Q*Y are the matrices of
 *  right or left eigenvectors of A.
 *
 *  T must be in Schur canonical form (as returned by DHSEQR), that is,
 *  block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 *  2-by-2 diagonal block has its diagonal elements equal and its
 *  off-diagonal elements of opposite sign.  Corresponding to each 2-by-2
 *  diagonal block is a complex conjugate pair of eigenvalues and
 *  eigenvectors; only one eigenvector of the pair is computed, namely
 *  the one corresponding to the eigenvalue with positive imaginary part.
 *
 *
 *  Arguments
 *  =========
 *
 *  SIDE    (input) CHARACTER*1
 *          = 'R':  compute right eigenvectors only;
 *          = 'L':  compute left eigenvectors only;
 *          = 'B':  compute both right and left eigenvectors.
 *
 *  HOWMNY  (input) CHARACTER*1
 *          = 'A':  compute all right and/or left eigenvectors;
 *          = 'B':  compute all right and/or left eigenvectors,
 *                  and backtransform them using the input matrices
 *                  supplied in VR and/or VL;
 *          = 'S':  compute selected right and/or left eigenvectors,
 *                  specified by the logical array SELECT.
 *
 *  SELECT  (input/output) LOGICAL array, dimension (N)
 *          If HOWMNY = 'S', SELECT specifies the eigenvectors to be
 *          computed.
 *          If HOWMNY = 'A' or 'B', SELECT is not referenced.
 *          To select the real eigenvector corresponding to a real
 *          eigenvalue w(j), SELECT(j) must be set to .TRUE..  To select
 *          the complex eigenvector corresponding to a complex conjugate
 *          pair w(j) and w(j+1), either SELECT(j) or SELECT(j+1) must be
 *          set to .TRUE.; then on exit SELECT(j) is .TRUE. and
 *          SELECT(j+1) is .FALSE..
 *
 *  N       (input) INTEGER
 *          The order of the matrix T. N >= 0.
 *
 *  T       (input) DOUBLE PRECISION array, dimension (LDT,N)
 *          The upper quasi-triangular matrix T in Schur canonical form.
 *
 *  LDT     (input) INTEGER
 *          The leading dimension of the array T. LDT >= max(1,N).
 *
 *  VL      (input/output) DOUBLE PRECISION array, dimension (LDVL,MM)
 *          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
 *          contain an N-by-N matrix Q (usually the orthogonal matrix Q
 *          of Schur vectors returned by DHSEQR).
 *          On exit, if SIDE = 'L' or 'B', VL contains:
 *          if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
 *          if HOWMNY = 'B', the matrix Q*Y;
 *          if HOWMNY = 'S', the left eigenvectors of T specified by
 *                           SELECT, stored consecutively in the columns
 *                           of VL, in the same order as their
 *                           eigenvalues.
 *          A complex eigenvector corresponding to a complex eigenvalue
 *          is stored in two consecutive columns, the first holding the
 *          real part, and the second the imaginary part.
 *          If SIDE = 'R', VL is not referenced.
 *
 *  LDVL    (input) INTEGER
 *          The leading dimension of the array VL.  LDVL >= max(1,N) if
 *          SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
 *
 *  VR      (input/output) DOUBLE PRECISION array, dimension (LDVR,MM)
 *          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
 *          contain an N-by-N matrix Q (usually the orthogonal matrix Q
 *          of Schur vectors returned by DHSEQR).
 *          On exit, if SIDE = 'R' or 'B', VR contains:
 *          if HOWMNY = 'A', the matrix X of right eigenvectors of T;
 *          if HOWMNY = 'B', the matrix Q*X;
 *          if HOWMNY = 'S', the right eigenvectors of T specified by
 *                           SELECT, stored consecutively in the columns
 *                           of VR, in the same order as their
 *                           eigenvalues.
 *          A complex eigenvector corresponding to a complex eigenvalue
 *          is stored in two consecutive columns, the first holding the
 *          real part and the second the imaginary part.
 *          If SIDE = 'L', VR is not referenced.
 *
 *  LDVR    (input) INTEGER
 *          The leading dimension of the array VR.  LDVR >= max(1,N) if
 *          SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
 *
 *  MM      (input) INTEGER
 *          The number of columns in the arrays VL and/or VR. MM >= M.
 *
 *  M       (output) INTEGER
 *          The number of columns in the arrays VL and/or VR actually
 *          used to store the eigenvectors.
 *          If HOWMNY = 'A' or 'B', M is set to N.
 *          Each selected real eigenvector occupies one column and each
 *          selected complex eigenvector occupies two columns.
 *
 *  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The algorithm used in this program is basically backward (forward)
 *  substitution, with scaling to make the the code robust against
 *  possible overflow.
 *
 *  Each eigenvector is normalized so that the element of largest
 *  magnitude has magnitude 1; here the magnitude of a complex number
 *  (x,y) is taken to be |x| + |y|.
 *
 *  =====================================================================
 *
 *     .. Parameters ..
</pre>
<p>
<hr>
<a name="index"></a>
<h2>
  <img src="images/constructor-index.gif" width=275 height=38 alt="Constructor Index">
</h2>
<dl>
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DTREVC()"><b>DTREVC</b></a>()
  <dd> 
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DTREVC(java.lang.String, java.lang.String, boolean[], int, double[][], double[][], double[][], int, org.netlib.util.intW, double[], org.netlib.util.intW)"><b>DTREVC</b></a>(String, String, boolean[], int, double[][], double[][], double[][], int, intW, double[], intW)
  <dd> 
</dl>
<a name="constructors"></a>
<h2>
  <img src="images/constructors.gif" width=231 height=38 alt="Constructors">
</h2>
<a name="DTREVC"></a>
<a name="DTREVC()"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>DTREVC</b>
<pre>
 public DTREVC()
</pre>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="DTREVC(java.lang.String, java.lang.String, boolean[], int, double[][], double[][], double[][], int, org.netlib.util.intW, double[], org.netlib.util.intW)"><img src="images/green-ball.gif" width=12 height=12 alt=" o "></a>
<a name="DTREVC"><b>DTREVC</b></a>
<pre>
 public static void DTREVC(String side,
                           String howmny,
                           boolean select[],
                           int n,
                           double t[][],
                           double vl[][],
                           double vr[][],
                           int mm,
                           <a href="org.netlib.util.intW.html#_top_">intW</a> m,
                           double work[],
                           <a href="org.netlib.util.intW.html#_top_">intW</a> info)
</pre>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.DTRCON.html#_top_">Previous</a>  <a href="org.netlib.lapack.DTREXC.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
