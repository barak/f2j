<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Fri Jan 22 13:19:44 EST 1999 -->
<title>
  Class org.netlib.lapack.DGEGV
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.DGEGS.html#_top_">Previous</a>  <a href="org.netlib.lapack.DGEHD2.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class org.netlib.lapack.DGEGV
</h1>
<pre>
java.lang.Object
   |
   +----org.netlib.lapack.DGEGV
</pre>
<hr>
<dl>
  <dt> public class <b>DGEGV</b>
  <dt> extends Object
</dl>
<pre>
<b>DGEGV</b> is a simplified interface to the JLAPACK routine <b>dgegv</b>.
This interface converts Java-style 2D row-major arrays into
the 1D column-major linearized arrays expected by the lower
level JLAPACK routines.  Using this interface also allows you
to omit offset and leading dimension arguments.  However, because
of these conversions, these routines will be slower than the low
level ones.  Following is the description from the original Fortran
source.  Contact <a href="mailto:seymour@cs.utk.edu">seymour@cs.utk.edu</a> with any questions.
<p>
 *     ..
 *
 *  Purpose
 *  =======
 *
 *  DGEGV computes for a pair of n-by-n real nonsymmetric matrices A and
 *  B, the generalized eigenvalues (alphar +/- alphai*i, beta), and
 *  optionally, the left and/or right generalized eigenvectors (VL and
 *  VR).
 *
 *  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
 *  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
 *  is singular.  It is usually represented as the pair (alpha,beta),
 *  as there is a reasonable interpretation for beta=0, and even for
 *  both being zero.  A good beginning reference is the book, "Matrix
 *  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
 *
 *  A right generalized eigenvector corresponding to a generalized
 *  eigenvalue  w  for a pair of matrices (A,B) is a vector  r  such
 *  that  (A - w B) r = 0 .  A left generalized eigenvector is a vector
 *  l such that l**H * (A - w B) = 0, where l**H is the
 *  conjugate-transpose of l.
 *
 *  Note: this routine performs "full balancing" on A and B -- see
 *  "Further Details", below.
 *
 *  Arguments
 *  =========
 *
 *  JOBVL   (input) CHARACTER*1
 *          = 'N':  do not compute the left generalized eigenvectors;
 *          = 'V':  compute the left generalized eigenvectors.
 *
 *  JOBVR   (input) CHARACTER*1
 *          = 'N':  do not compute the right generalized eigenvectors;
 *          = 'V':  compute the right generalized eigenvectors.
 *
 *  N       (input) INTEGER
 *          The order of the matrices A, B, VL, and VR.  N >= 0.
 *
 *  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
 *          On entry, the first of the pair of matrices whose
 *          generalized eigenvalues and (optionally) generalized
 *          eigenvectors are to be computed.
 *          On exit, the contents will have been destroyed.  (For a
 *          description of the contents of A on exit, see "Further
 *          Details", below.)
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of A.  LDA >= max(1,N).
 *
 *  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
 *          On entry, the second of the pair of matrices whose
 *          generalized eigenvalues and (optionally) generalized
 *          eigenvectors are to be computed.
 *          On exit, the contents will have been destroyed.  (For a
 *          description of the contents of B on exit, see "Further
 *          Details", below.)
 *
 *  LDB     (input) INTEGER
 *          The leading dimension of B.  LDB >= max(1,N).
 *
 *  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
 *  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
 *  BETA    (output) DOUBLE PRECISION array, dimension (N)
 *          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
 *          be the generalized eigenvalues.  If ALPHAI(j) is zero, then
 *          the j-th eigenvalue is real; if positive, then the j-th and
 *          (j+1)-st eigenvalues are a complex conjugate pair, with
 *          ALPHAI(j+1) negative.
 *
 *          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
 *          may easily over- or underflow, and BETA(j) may even be zero.
 *          Thus, the user should avoid naively computing the ratio
 *          alpha/beta.  However, ALPHAR and ALPHAI will be always less
 *          than and usually comparable with norm(A) in magnitude, and
 *          BETA always less than and usually comparable with norm(B).
 *
 *  VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
 *          If JOBVL = 'V', the left generalized eigenvectors.  (See
 *          "Purpose", above.)  Real eigenvectors take one column,
 *          complex take two columns, the first for the real part and
 *          the second for the imaginary part.  Complex eigenvectors
 *          correspond to an eigenvalue with positive imaginary part.
 *          Each eigenvector will be scaled so the largest component
 *          will have abs(real part) + abs(imag. part) = 1, *except*
 *          that for eigenvalues with alpha=beta=0, a zero vector will
 *          be returned as the corresponding eigenvector.
 *          Not referenced if JOBVL = 'N'.
 *
 *  LDVL    (input) INTEGER
 *          The leading dimension of the matrix VL. LDVL >= 1, and
 *          if JOBVL = 'V', LDVL >= N.
 *
 *  VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
 *          If JOBVL = 'V', the right generalized eigenvectors.  (See
 *          "Purpose", above.)  Real eigenvectors take one column,
 *          complex take two columns, the first for the real part and
 *          the second for the imaginary part.  Complex eigenvectors
 *          correspond to an eigenvalue with positive imaginary part.
 *          Each eigenvector will be scaled so the largest component
 *          will have abs(real part) + abs(imag. part) = 1, *except*
 *          that for eigenvalues with alpha=beta=0, a zero vector will
 *          be returned as the corresponding eigenvector.
 *          Not referenced if JOBVR = 'N'.
 *
 *  LDVR    (input) INTEGER
 *          The leading dimension of the matrix VR. LDVR >= 1, and
 *          if JOBVR = 'V', LDVR >= N.
 *
 *  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
 *          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK.  LWORK >= max(1,8*N).
 *          For good performance, LWORK must generally be larger.
 *          To compute the optimal value of LWORK, call ILAENV to get
 *          blocksizes (for DGEQRF, DORMQR, and DORGQR.)  Then compute:
 *          NB  -- MAX of the blocksizes for DGEQRF, DORMQR, and DORGQR;
 *          The optimal LWORK is:
 *              2*N + MAX( 6*N, N*(NB+1) ).
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  if INFO = -i, the i-th argument had an illegal value.
 *          = 1,...,N:
 *                The QZ iteration failed.  No eigenvectors have been
 *                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
 *                should be correct for j=INFO+1,...,N.
 *          > N:  errors that usually indicate LAPACK problems:
 *                =N+1: error return from DGGBAL
 *                =N+2: error return from DGEQRF
 *                =N+3: error return from DORMQR
 *                =N+4: error return from DORGQR
 *                =N+5: error return from DGGHRD
 *                =N+6: error return from DHGEQZ (other than failed
 *                                                iteration)
 *                =N+7: error return from DTGEVC
 *                =N+8: error return from DGGBAK (computing VL)
 *                =N+9: error return from DGGBAK (computing VR)
 *                =N+10: error return from DLASCL (various calls)
 *
 *  Further Details
 *  ===============
 *
 *  Balancing
 *  ---------
 *
 *  This driver calls DGGBAL to both permute and scale rows and columns
 *  of A and B.  The permutations PL and PR are chosen so that PL*A*PR
 *  and PL*B*R will be upper triangular except for the diagonal blocks
 *  A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
 *  possible.  The diagonal scaling matrices DL and DR are chosen so
 *  that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
 *  one (except for the elements that start out zero.)
 *
 *  After the eigenvalues and eigenvectors of the balanced matrices
 *  have been computed, DGGBAK transforms the eigenvectors back to what
 *  they would have been (in perfect arithmetic) if they had not been
 *  balanced.
 *
 *  Contents of A and B on Exit
 *  -------- -- - --- - -- ----
 *
 *  If any eigenvectors are computed (either JOBVL='V' or JOBVR='V' or
 *  both), then on exit the arrays A and B will contain the real Schur
 *  form[*] of the "balanced" versions of A and B.  If no eigenvectors
 *  are computed, then only the diagonal blocks will be correct.
 *
 *  [*] See DHGEQZ, DGEGS, or read the book "Matrix Computations",
 *      by Golub & van Loan, pub. by Johns Hopkins U. Press.
 *
 *  =====================================================================
 *
 *     .. Parameters ..
</pre>
<p>
<hr>
<a name="index"></a>
<h2>
  <img src="images/constructor-index.gif" width=275 height=38 alt="Constructor Index">
</h2>
<dl>
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DGEGV()"><b>DGEGV</b></a>()
  <dd> 
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DGEGV(java.lang.String, java.lang.String, int, double[][], double[][], double[], double[], double[], double[][], double[][], double[], int, org.netlib.util.intW)"><b>DGEGV</b></a>(String, String, int, double[][], double[][], double[], double[], double[], double[][], double[][], double[], int, intW)
  <dd> 
</dl>
<a name="constructors"></a>
<h2>
  <img src="images/constructors.gif" width=231 height=38 alt="Constructors">
</h2>
<a name="DGEGV"></a>
<a name="DGEGV()"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>DGEGV</b>
<pre>
 public DGEGV()
</pre>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="DGEGV(java.lang.String, java.lang.String, int, double[][], double[][], double[], double[], double[], double[][], double[][], double[], int, org.netlib.util.intW)"><img src="images/green-ball.gif" width=12 height=12 alt=" o "></a>
<a name="DGEGV"><b>DGEGV</b></a>
<pre>
 public static void DGEGV(String jobvl,
                          String jobvr,
                          int n,
                          double a[][],
                          double b[][],
                          double alphar[],
                          double alphai[],
                          double beta[],
                          double vl[][],
                          double vr[][],
                          double work[],
                          int lwork,
                          <a href="org.netlib.util.intW.html#_top_">intW</a> info)
</pre>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.DGEGS.html#_top_">Previous</a>  <a href="org.netlib.lapack.DGEHD2.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
