<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Fri Jan 22 13:19:44 EST 1999 -->
<title>
  Class org.netlib.lapack.Dtrsna
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.Dtrsen.html#_top_">Previous</a>  <a href="org.netlib.lapack.Dtrsyl.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class org.netlib.lapack.Dtrsna
</h1>
<pre>
java.lang.Object
   |
   +----org.netlib.lapack.Dtrsna
</pre>
<hr>
<dl>
  <dt> public class <b>Dtrsna</b>
  <dt> extends Object
</dl>
<pre>
Following is the description from the original
Fortran source.  For each array argument, the Java
version will include an integer offset parameter, so
the arguments may not match the description exactly.
Contact <a href="mailto:seymour@cs.utk.edu">seymour@cs.utk.edu</a> with any questions.
<p>
 *     ..
 *
 *  Purpose
 *  =======
 *
 *  DTRSNA estimates reciprocal condition numbers for specified
 *  eigenvalues and/or right eigenvectors of a real upper
 *  quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
 *  orthogonal).
 *
 *  T must be in Schur canonical form (as returned by DHSEQR), that is,
 *  block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 *  2-by-2 diagonal block has its diagonal elements equal and its
 *  off-diagonal elements of opposite sign.
 *
 *  Arguments
 *  =========
 *
 *  JOB     (input) CHARACTER*1
 *          Specifies whether condition numbers are required for
 *          eigenvalues (S) or eigenvectors (SEP):
 *          = 'E': for eigenvalues only (S);
 *          = 'V': for eigenvectors only (SEP);
 *          = 'B': for both eigenvalues and eigenvectors (S and SEP).
 *
 *  HOWMNY  (input) CHARACTER*1
 *          = 'A': compute condition numbers for all eigenpairs;
 *          = 'S': compute condition numbers for selected eigenpairs
 *                 specified by the array SELECT.
 *
 *  SELECT  (input) LOGICAL array, dimension (N)
 *          If HOWMNY = 'S', SELECT specifies the eigenpairs for which
 *          condition numbers are required. To select condition numbers
 *          for the eigenpair corresponding to a real eigenvalue w(j),
 *          SELECT(j) must be set to .TRUE.. To select condition numbers
 *          corresponding to a complex conjugate pair of eigenvalues w(j)
 *          and w(j+1), either SELECT(j) or SELECT(j+1) or both, must be
 *          set to .TRUE..
 *          If HOWMNY = 'A', SELECT is not referenced.
 *
 *  N       (input) INTEGER
 *          The order of the matrix T. N >= 0.
 *
 *  T       (input) DOUBLE PRECISION array, dimension (LDT,N)
 *          The upper quasi-triangular matrix T, in Schur canonical form.
 *
 *  LDT     (input) INTEGER
 *          The leading dimension of the array T. LDT >= max(1,N).
 *
 *  VL      (input) DOUBLE PRECISION array, dimension (LDVL,M)
 *          If JOB = 'E' or 'B', VL must contain left eigenvectors of T
 *          (or of any Q*T*Q**T with Q orthogonal), corresponding to the
 *          eigenpairs specified by HOWMNY and SELECT. The eigenvectors
 *          must be stored in consecutive columns of VL, as returned by
 *          DHSEIN or DTREVC.
 *          If JOB = 'V', VL is not referenced.
 *
 *  LDVL    (input) INTEGER
 *          The leading dimension of the array VL.
 *          LDVL >= 1; and if JOB = 'E' or 'B', LDVL >= N.
 *
 *  VR      (input) DOUBLE PRECISION array, dimension (LDVR,M)
 *          If JOB = 'E' or 'B', VR must contain right eigenvectors of T
 *          (or of any Q*T*Q**T with Q orthogonal), corresponding to the
 *          eigenpairs specified by HOWMNY and SELECT. The eigenvectors
 *          must be stored in consecutive columns of VR, as returned by
 *          DHSEIN or DTREVC.
 *          If JOB = 'V', VR is not referenced.
 *
 *  LDVR    (input) INTEGER
 *          The leading dimension of the array VR.
 *          LDVR >= 1; and if JOB = 'E' or 'B', LDVR >= N.
 *
 *  S       (output) DOUBLE PRECISION array, dimension (MM)
 *          If JOB = 'E' or 'B', the reciprocal condition numbers of the
 *          selected eigenvalues, stored in consecutive elements of the
 *          array. For a complex conjugate pair of eigenvalues two
 *          consecutive elements of S are set to the same value. Thus
 *          S(j), SEP(j), and the j-th columns of VL and VR all
 *          correspond to the same eigenpair (but not in general the
 *          j-th eigenpair, unless all eigenpairs are selected).
 *          If JOB = 'V', S is not referenced.
 *
 *  SEP     (output) DOUBLE PRECISION array, dimension (MM)
 *          If JOB = 'V' or 'B', the estimated reciprocal condition
 *          numbers of the selected eigenvectors, stored in consecutive
 *          elements of the array. For a complex eigenvector two
 *          consecutive elements of SEP are set to the same value. If
 *          the eigenvalues cannot be reordered to compute SEP(j), SEP(j)
 *          is set to 0; this can only occur when the true value would be
 *          very small anyway.
 *          If JOB = 'E', SEP is not referenced.
 *
 *  MM      (input) INTEGER
 *          The number of elements in the arrays S (if JOB = 'E' or 'B')
 *           and/or SEP (if JOB = 'V' or 'B'). MM >= M.
 *
 *  M       (output) INTEGER
 *          The number of elements of the arrays S and/or SEP actually
 *          used to store the estimated condition numbers.
 *          If HOWMNY = 'A', M is set to N.
 *
 *  WORK    (workspace) DOUBLE PRECISION array, dimension (LDWORK,N+1)
 *          If JOB = 'E', WORK is not referenced.
 *
 *  LDWORK  (input) INTEGER
 *          The leading dimension of the array WORK.
 *          LDWORK >= 1; and if JOB = 'V' or 'B', LDWORK >= N.
 *
 *  IWORK   (workspace) INTEGER array, dimension (N)
 *          If JOB = 'E', IWORK is not referenced.
 *
 *  INFO    (output) INTEGER
 *          = 0: successful exit
 *          < 0: if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The reciprocal of the condition number of an eigenvalue lambda is
 *  defined as
 *
 *          S(lambda) = |v'*u| / (norm(u)*norm(v))
 *
 *  where u and v are the right and left eigenvectors of T corresponding
 *  to lambda; v' denotes the conjugate-transpose of v, and norm(u)
 *  denotes the Euclidean norm. These reciprocal condition numbers always
 *  lie between zero (very badly conditioned) and one (very well
 *  conditioned). If n = 1, S(lambda) is defined to be 1.
 *
 *  An approximate error bound for a computed eigenvalue W(i) is given by
 *
 *                      EPS * norm(T) / S(i)
 *
 *  where EPS is the machine precision.
 *
 *  The reciprocal of the condition number of the right eigenvector u
 *  corresponding to lambda is defined as follows. Suppose
 *
 *              T = ( lambda  c  )
 *                  (   0    T22 )
 *
 *  Then the reciprocal condition number is
 *
 *          SEP( lambda, T22 ) = sigma-min( T22 - lambda*I )
 *
 *  where sigma-min denotes the smallest singular value. We approximate
 *  the smallest singular value by the reciprocal of an estimate of the
 *  one-norm of the inverse of T22 - lambda*I. If n = 1, SEP(1) is
 *  defined to be abs(T(1,1)).
 *
 *  An approximate error bound for a computed right eigenvector VR(i)
 *  is given by
 *
 *                      EPS * norm(T) / SEP(i)
 *
 *  =====================================================================
 *
 *     .. Parameters ..
</pre>
<p>
<hr>
<a name="index"></a>
<h2>
  <img src="images/constructor-index.gif" width=275 height=38 alt="Constructor Index">
</h2>
<dl>
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#Dtrsna()"><b>Dtrsna</b></a>()
  <dd> 
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#dtrsna(java.lang.String, java.lang.String, boolean[], int, int, double[], int, int, double[], int, int, double[], int, int, double[], int, double[], int, int, org.netlib.util.intW, double[], int, int, int[], int, org.netlib.util.intW)"><b>dtrsna</b></a>(String, String, boolean[], int, int, double[], int, int, double[], int, int, double[], int, int, double[], int, double[], int, int, intW, double[], int, int, int[], int, intW)
  <dd> 
</dl>
<a name="constructors"></a>
<h2>
  <img src="images/constructors.gif" width=231 height=38 alt="Constructors">
</h2>
<a name="Dtrsna"></a>
<a name="Dtrsna()"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>Dtrsna</b>
<pre>
 public Dtrsna()
</pre>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="dtrsna(java.lang.String, java.lang.String, boolean[], int, int, double[], int, int, double[], int, int, double[], int, int, double[], int, double[], int, int, org.netlib.util.intW, double[], int, int, int[], int, org.netlib.util.intW)"><img src="images/green-ball.gif" width=12 height=12 alt=" o "></a>
<a name="dtrsna"><b>dtrsna</b></a>
<pre>
 public static void dtrsna(String job,
                           String howmny,
                           boolean select[],
                           int _select_offset,
                           int n,
                           double t[],
                           int _t_offset,
                           int ldt,
                           double vl[],
                           int _vl_offset,
                           int ldvl,
                           double vr[],
                           int _vr_offset,
                           int ldvr,
                           double s[],
                           int _s_offset,
                           double sep[],
                           int _sep_offset,
                           int mm,
                           <a href="org.netlib.util.intW.html#_top_">intW</a> m,
                           double work[],
                           int _work_offset,
                           int ldwork,
                           int iwork[],
                           int _iwork_offset,
                           <a href="org.netlib.util.intW.html#_top_">intW</a> info)
</pre>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.Dtrsen.html#_top_">Previous</a>  <a href="org.netlib.lapack.Dtrsyl.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
