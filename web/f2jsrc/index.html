<html>
<head>
<title>f2j source</title>
</head>

<body>
<h1>Fortran-to-Java Source Code</h1>
<p>
Before downloading the f2j source code, realize
that f2j is a specific tool geared to a specific
problem - that is, translating LAPACK.  However,
the goal is to handle as much Fortran as possible
and there's still a lot left to cover.  
Unfortunately, f2j development has been at
a standstill for the last couple of years
as the developers have been off working on
other projects.  This is where we believe 
the development community (i.e. <i>you</i>) comes in.
We have a lot of confidence in the JLAPACK
translation, but f2j will
most likely not correctly translate your code
at first.  It may not parse or the code generation
may not be correct or whatever.  We hope that
if you can extend f2j to handle your code, that
you'll send us diffs so that we may then incorporate
your fixes into our codebase.  Eventually we may
put the code up on a public CVS server, but
for now, we'll handle that stuff locally.
The structure of the code is pretty typical for
a compiler project.  We have a lexer/parser
on the front-end that builds an Abstract Syntax Tree
which is then passed to the back-end for code
generation.

<h2>Building and Using <code>f2java</code></h2>
<p>We have been doing development and testing of
f2j on Sun workstations running various versions
of Solaris.  It may compile on other platforms,
though.  At least it's worth a shot.  Depending on the
compiler, you may see some warnings about unused
variables, etc.  You can safely ignore them.
<p>
First, download and unzip the source code.
<p>
Go into the <code>f2jsrc</code> directory and type <code>make</code>.
<p>
You may want to add <code>f2jsrc/bin</code> to your PATH because
that's the directory in which <code>f2java</code> and <code>javab</code>
(the goto translator) are placed.
<p>
To translate a Fortran source file named <code>blah.f</code>,
issue the command <code>f2java blah.f</code>.  There are several
command-line options that you should be aware of:
<ul>
<li><b><code>-p packagename</code></b> <i>places the specified package name
in the generated Java source code</i>.</li>
<li><b><code>-w</code></b>  <i>forces all scalars to be generated as
wrapped objects.  The default behavior is to only
wrap those scalars that must be passed by reference.  Note that
using this option will generate less efficient Java code.</i>
</li>
<li><b><code>-i</code></b> <i>causes f2j to generate a high-level
interface to each subroutine and function.  The high-level interface
uses a Java-style calling convention (2D row-major arrays, etc).  The
low-level routine is still generated because the high-level interface
simply performs some conversions and then calls the low-level routine.</i></li>
<li><b><code>-h</code></b> <i>displays help information</i>.</li>
<li><b><code>-s</code></b> <i>causes f2j to simplify the interfaces
by removing the offset parameter and using a zero offset.
It isn't necessary to specify the -i flag in addition
to the -s</i>.</li>
<li><b><code>-d</code></b> <i>causes f2j to generate comments in
a format suitable for javadoc.  It is a bit of a LAPACK-
specfic hack...the longest comment in the program unit
is placed in the javadoc comment.  It works fine for
BLAS/LAPACK code (or any other code where the longest
comment is the one that describes the function), but
will most likely not work for other code</i>.</li>
</ul>
<p>
After issuing the command <code>f2java blah.f</code>, there should
be one or more Java files in your current directory, one Java file
per Fortran program unit (function, subroutine, program) in the
source file.  We suggest concatenating all Fortran program units
into one file because it allows f2j to perform more accurate
code generation (more about this later).  Now you can use the
Java compiler of your choice to compile the resulting code.  Make
sure that the <code>org.netlib.util</code> package is in your
<code>CLASSPATH</code>.  This package comes in the JLAPACK distribution,
so if your CLASSPATH already points to jlapack's classes.zip, then
you're ok.  If you dont want to download all of jlapack, you
can download just the <code>org.netlib.util</code> classes
<a href="util.tgz">here</a>.
<p>
If successful, compiling the Java code will result in
one or more Java class files being generated.  Before you
can execute the class files, you need to perform the
GOTO translation by issuing the command <code>javab *.class</code>
(assuming that all your class files are in the current directory).
The GOTO translation tool replaces the class files with the updated
versions while leaving copies of the old class files in files named
*.old.

<p>
If all the above steps went well, you should be able to
execute the class files in the Java environment of your choice.
The next section deals with what to do if some of the steps
didn't work correctly.
<h2>Extending f2j</h2>
<p>So, at this point you may be wondering how
to extend f2j to handle your code.  Typically, the
first problem you'll run into is that f2j doesn't
parse your code.  That could involve something as
simple as changing a production in the parser
or it could involve a bit more work - e.g. creating
a new kind of AST node along with all the 
appropriate code generation routines.  The first
thing you'll want to check is whether the parser
supports the syntax your code uses
(the parsing code is machine generated
from a Yacc parser in f2jparse.y). 
For example,
if your code contains an IMPLICIT statement (besides
IMPLICIT NONE), your code will not compile because
f2j doesn't support implicit typing.  Suppose you
wanted to implement implicit typing in f2j.  Your
first step would be to modify the "Implicit" production
in the parser to allow the statement.  Then you'd
probably have to modify the "type assignment" code in
typecheck.c, but you shouldn't need to change the
code generator (codegen.c).  The second thing you'll
want to check if your code doesn't parse is whether
the lexer is acting up.  If you're getting parse
errors on a line of code that <i>should</i> compile
based on your examination of the parser, then
the lexer might not be sending the correct tokens
to the parser.  
The lexical analysis code is
in f2jlex.c, which is handwritten C code based
on Sale's algorithm.  
There's not really an easy way of describing the
structure of the lexer code, but if you enable
debugging output (set <code>lexdebug = TRUE</code>) it should
help you figure out where the problem is.
<p>
If f2j can parse your code, but the resulting
Java code does not compile or does not work, then
this may indicate a problem in the f2j back-end.
First, try concatenating all your fortran files
into one big file (ok, we admit this is cheesy,
but we haven't implemented multiple file handling yet).
This should help with the type analysis phase and
may eliminate problems in the resulting Java code.
After that, if the generated code is still incorrect,
begin looking into the f2j code.  After f2j parses
your code, it passes through a couple of stages
before actually generating code.  First, the AST
goes through 'type analysis' (typecheck.c), which simply means
that the tree is fully traversed and each node is
assigned type information as appropriate.  This is
not semantic analysis, just annotation.  Next, the
AST goes through 'scalar optimization' (optimize.c), which is
an optimization stage designed to determine which
scalar variables need to be wrapped in objects and
which can remain primitives.  After that, f2j generates
the java code (codegen.c) based on the modified AST.
So, if you notice a type mismatch problem in the generated code,
typecheck.c would be a good place to begin debugging.
Similarly, if you notice that object wrappers are
inappropriately used, check into optimize.c (hint: by passing
the -w flag to f2java, the scalar optimization code will
be skipped).  Most other problems will be with the
code generator itself.
<p>
If you're ambitious, you might try grafting a full
Fortran 77 front-end onto f2j and start building up the
back-end to accommodate all the new AST nodes.
Or you might just try fully implementing Fortran's I/O
routines for f2j.

<h2>Tips</h2>
<ul><li><code>f2java -h</code> provides a help screen.</li>
    <li>For best results, concatenate all Fortran files into one source file.</li>
    <li>Remember to run the goto translation program on the resulting bytecode.</li>
    <li>Jasmin code generation is broken.</li>
    <li>VCG graph generation is broken, too.</li>
    <li>Last line of input can't begin with a TAB.</li>
    <li>DIMENSION not implemented.</li>
    <li>more to come...</li>
</ul>
</p>
<h2>Download</h2>

<p>Currently, just a <a href="f2jsrc.tar.gz">tarball 
of source</a> capable of correctly 
translating LAPACK 2 is available.  Future plans 
include adding documentation of the source,
documentation on how to use the source to 
translate, and perhaps a pointer on how to 
jlapack.</p>

<h2>LICENSE</h2>
<p>The <a href="license.html">license covering the f2j source code</a> is
basically GPL with the addition of the BSD advertising
clause.

<p>The GOTO translation code is based on the bytecode parser found in
<b>javab</b>, a bytecode parallelizing tool under development at the
University of Indiana.  This code is covered under its
<a href="javab_license.html">original license</a>,
found in the translator source directory.
<hr>

Updated: 22 Mar., 2000

</body>
</html>
